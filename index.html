<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tiny Flashcards</title>
  <style>
    :root { --bg:#000; --fg:#fff; --muted:#9a9a9a; }
    *{ box-sizing:border-box }
    html,body{ height:100%; margin:0 }

    /* Full, crisp background image that always fills screen */
    body{
      font-family:"Times New Roman", Georgia, serif;
      color:var(--fg);
      background: url('bg.jpg') center/cover no-repeat fixed;
      display:block;
      min-height:100vh;
    }

    .app{ width:min(860px,94%); margin:14vh auto 24vh; display:grid; gap:28px }

.card{
  border: 3px solid var(--fg);
  border-radius: 40px;
  /* make the actual card transparent… */
  background: transparent;
  /* …and draw the black panel inside with ::before */
  position: relative;
  padding: 64px 44px 36px;
  text-align: center;
}

/* inner black panel, inset from the white border */
.card::before{
  content: "";
  position: absolute;
  inset: 2px;                        /* tweak this to change how much black you see */
  background: rgba(0,0,0,0.8);
  border-radius: calc(40px - 12px);   /* keep corners nicely rounded */
  z-index: 0;
}

/* ensure your content sits above the inner panel */
.card > * { position: relative; z-index: 1; }


    #stage{ min-height:clamp(220px,40vh,420px); display:grid; place-items:center; gap:14px }

    .prompt{ font-size:clamp(34px,3.8vw,50px); letter-spacing:.3px; margin:0 }
    .translation{ display:block; min-height:2.6em; font-size:clamp(26px,2.9vw,38px); color:var(--muted); transition:opacity .15s ease }
    .translation.hidden{ visibility:hidden; opacity:0 }
    .translation.visible{ visibility:visible; opacity:.95 }

    .row{ display:flex; justify-content:center; gap:18px; margin-top:28px }
    button{ font:18px/1.2 inherit; color:var(--fg); background:transparent; border:2px solid var(--fg); border-radius:50px; padding:12px 30px; cursor:pointer; transition:all .15s ease }
    button:hover{ background:var(--fg); color:var(--bg) }
    button:disabled{ opacity:.35; cursor:not-allowed }


  .footer {
  text-align: center;
  font-size: 14px;
  letter-spacing: 0.6px;
  font-weight: bold;
  color: #39FF14;       /* neon green */
  text-shadow: 0 0 8px #39FF14, 0 0 12px #39FF14; /* glowing neon effect */
}


  <script>
    let deck = [
      { q: "Ī ad popīnam pedibus.", a: "Go to the restaurant on foot." },
      { q: "Ī ad librāriam bīrotā.", a: "Go to the bookstore by bike." },
      { q: "Dic 'sōl est.'", a: "Say 'it is the sun.'" },
      { q: "Quot gladīī sunt?", a: "How many swords are there?" },
      { q: "Unus gladius est.", a: "There is one sword." }
    ];

    const DECK_URLS = Array.from({length: 20}, (_, i) => `decks/b${i+1}.txt`);

    const el = (id) => document.getElementById(id);
    const lineText = el('lineText');
    const lineTrans = el('lineTrans');
    const nextBtn = el('nextBtn');
    const prevBtn = el('prevBtn');

    let order = deck.map((_, i) => i);
    let idx = 0;
    let showingA = false;

    function rebuildOrder(){
      order = deck.map((_, i) => i);
      idx = 0;
      showingA = false;
      render();
    }

    function render(){
      const current = deck[ order[idx] ];
      if(!current){
        lineText.textContent = "(No cards)";
        lineTrans.classList.add('hidden');
        nextBtn.disabled = true; prevBtn.disabled = true;
        return;
      }
      nextBtn.disabled = false; prevBtn.disabled = false;
      lineText.textContent = current.q;
      lineTrans.textContent = current.a;
      lineTrans.classList.toggle('visible', showingA);
      lineTrans.classList.toggle('hidden', !showingA);
    }

    function next(){
      if(deck.length===0) return;
      if(!showingA){
        showingA = true;
      } else {
        if(idx < order.length - 1){
          idx++;
          showingA = false;
        } else {
          idx = 0;
          showingA = false;
        }
      }
      render();
    }

    function prev(){
      if(deck.length===0) return;
      if(showingA){
        showingA = false;
      } else if(idx>0){
        idx--; showingA = false;
      }
      render();
    }

    nextBtn.addEventListener('click', next);
    prevBtn.addEventListener('click', prev);

    window.addEventListener('keydown', (e) => {
      if(e.code === 'Space' || e.key === 'ArrowRight'){ e.preventDefault(); next(); }
      if(e.key === 'ArrowLeft'){ e.preventDefault(); prev(); }
    });

    function parseLinesToDeck(text){
      const lines = text.split(/\n+/).map(s=>s.trim()).filter(Boolean);
      const out = [];
      for(const line of lines){
        const parts = line.split(/\s*(?:=|—|-|:)\s*/);
        if(parts.length>=2){
          const q = parts[0].trim();
          const a = parts.slice(1).join(' - ').trim();
          if(q && a) out.push({q,a});
        }
      }
      return out;
    }

    async function loadRandomDeckFromUrls(){
      if(!Array.isArray(DECK_URLS) || !DECK_URLS.length) return false;
      const pick = DECK_URLS[Math.floor(Math.random()*DECK_URLS.length)];
      try{
        const res = await fetch(pick, {cache:'no-store'});
        if(!res.ok) throw new Error(res.status+' '+res.statusText);
        const text = await res.text();
        const parsed = parseLinesToDeck(text);
        if(parsed.length){ deck = parsed; return true; }
      }catch(e){ console.warn('Random deck load failed:', e); }
      return false;
    }

    loadRandomDeckFromUrls().then(()=>{ rebuildOrder(); });
  </script>
</body>
</html>

